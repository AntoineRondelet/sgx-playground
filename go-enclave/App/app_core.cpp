#include <stdio.h>
#include <iostream>
/**
 * enclave_u.h is generated by the Edger8r tool.
 * The generation of edge routines is done by reading the EDL file.
 * The suffix "_u" means "untrusted", and is used to make
 * enclave calls from the untrusted part of the application.
 * The enclave_u.h file gives an interface to the untrusted
 * part of the application to interact with the trusted part in the enclave
 */
#include "enclave_u.h"
#include "sgx_urts.h"
#include "enclave_manager.h"

#define TOKEN_FILE "enclave.token"
#define ENCLAVE_FILE "enclave.signed.so"

// Global enclave ID
sgx_enclave_id_t enclave_id = 0;

/**
 * Implementation of the untrusted (the OCALLs) part of the enclave.edl file
 */
void ocall_print(const char* str) {
    printf("%s\n", str);
}

/**
 * Main program
 */
int main(int argc, char const *argv[]) {
    int result_init = init_enclave(&enclave_id, TOKEN_FILE, ENCLAVE_FILE);
    if (result_init < 0) {
        std::cout << "Could not initialize the enclave" << std::endl;
        return 1;
    }

    int result_addition = 10;
    int first_term = 12;
    int second_term = 34;
    /**
     * Perform an addition in the enclave
     * The addition function from the enclave calls a go function
     */
    printf("Value of the result_addition variable BEFORE call to enclave: %d\n", result_addition);
    sgx_status_t status = test(enclave_id, &result_addition, first_term, second_term);
    if (status != SGX_SUCCESS) {
        std::cout << "The addition call in the enclave failed" << std::endl;
    }
    printf("Value of the result_addition variable AFTER call to enclave: %d\n", result_addition);

    // Destruction of the enclave once we are done with it (no more ECALLs to do)
    if(SGX_SUCCESS != sgx_destroy_enclave(enclave_id)) {
        return -1;
    }

    return 0;
}
